# -*- coding: utf-8 -*-
"""IPL Score Predictor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OhY9I9QbhKRgEp1OaOO431yvQev70nRw

**Prerequisites**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import sklearn
from sklearn import preprocessing
import keras
import tensorflow as tf
import torch

from sklearn import preprocessing
from sklearn.preprocessing import LabelEncoder, MinMaxScaler
from sklearn.model_selection import train_test_split
from torch import nn
from torch.utils.data import DataLoader, TensorDataset
import keras
import tensorflow as tf
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

import ipywidgets as widgets
from IPython.display import display, clear_output
import warnings

warnings.filterwarnings("ignore")

import pandas as pd

# Load the dataset
ipl = pd.read_csv('/content/ipl_data.csv')

# Drop certain unimportant features
df = ipl.drop(['date', 'runs', 'wickets', 'overs', 'runs_last_5', 'wickets_last_5','mid', 'striker', 'non-striker'], axis =1)

# dropping certain unimpotant features

X = df.drop(['total'], axis =1)
y = df['total']

df.head()

# spliting the data frame into independent variable (X) and dependent variables (y)

from sklearn.preprocessing import LabelEncoder

"""**Label Encoding**"""

# Create a LabelEncoder object for each categorical feature
venue_encoder = LabelEncoder()
batting_team_encoder = LabelEncoder()
bowling_team_encoder = LabelEncoder()
striker_encoder = LabelEncoder()
bowler_encoder = LabelEncoder()

# Fit and transform the categorical features with label encoding
X['venue'] = venue_encoder.fit_transform(X['venue'])
X['bat_team'] = batting_team_encoder.fit_transform(X['bat_team'])
X['bowl_team'] = bowling_team_encoder.fit_transform(X['bowl_team'])
X['batsman'] = striker_encoder.fit_transform(X['batsman'])
X['bowler'] = bowler_encoder.fit_transform(X['bowler'])

"""**Train Test Split**"""

# Train test Split
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

"""**Data Scaling**"""

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()

# Fit the scaler on the training data and transform both training and testing data
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

"""**Defining & Training Model**"""

# Define the neural network model
model = keras.Sequential([
    keras.layers.Input(shape=(X_train_scaled.shape[1],)),  # Input layer
    keras.layers.Dense(512, activation='relu'),
    keras.layers.Dense(512, activation='relu'),  # Adding another layer with 512 Units
    keras.layers.Dense(256, activation='relu'),
    keras.layers.Dense(128, activation='relu'),
    keras.layers.Dense(64, activation='relu'),
    keras.layers.Dense(32, activation='relu'),  # Adding another layer with 32 Units
    keras.layers.Dense(1, activation='linear')  # Output layer with linear activation
])

# Compile the model with Huber loss
huber_loss = tf.keras.losses.Huber(delta=1.0)  # You can adjust the 'delta' parameter as needed
model.compile(optimizer='adam', loss=huber_loss)  # Use Huber loss for regression

# Train the model
model.fit(X_train_scaled, y_train, epochs=50, batch_size=64, validation_data=(X_test_scaled, y_test))

model_losses = pd.DataFrame(model.history.history)
model_losses.plot()

"""**Prediction & Evaluation**"""

# Make predictions
predictions = model.predict(X_test_scaled)

from sklearn.metrics import mean_absolute_error,mean_squared_error
mean_absolute_error(y_test,predictions)
print(f'Mean Absolute Error: {mean_absolute_error(y_test,predictions)}')

import ipywidgets as widgets
from IPython.display import display, clear_output

import warnings
warnings.filterwarnings("ignore")

venue = widgets.Dropdown(options=df['venue'].unique().tolist(),description='Select Venue:')
batting_team = widgets.Dropdown(options =df['bat_team'].unique().tolist(),  description='Select Batting Team:')
bowling_team = widgets.Dropdown(options=df['bowl_team'].unique().tolist(),  description='Select Batting Team:')
striker = widgets.Dropdown(options=df['batsman'].unique().tolist(), description='Select Striker:')
bowler = widgets.Dropdown(options=df['bowler'].unique().tolist(), description='Select Bowler:')

predict_button = widgets.Button(description="Predict Score")

def predict_score(b):
    with output:
        clear_output()  # Clear the previous output


        # Decode the encoded values back to their original values
        decoded_venue = venue_encoder.transform([venue.value])
        decoded_batting_team = batting_team_encoder.transform([batting_team.value])
        decoded_bowling_team = bowling_team_encoder.transform([bowling_team.value])
        decoded_striker = striker_encoder.transform([striker.value])
        decoded_bowler = bowler_encoder.transform([bowler.value])


        input = np.array([decoded_venue,  decoded_batting_team, decoded_bowling_team,decoded_striker, decoded_bowler])
        input = input.reshape(1,5)
        input = scaler.transform(input)
        #print(input)
        predicted_score = model.predict(input)
        predicted_score = int(predicted_score[0,0])

        print(f'Predicted Score:{predicted_score}')


predict_button.on_click(predict_score)
output = widgets.Output()
display(venue, batting_team, bowling_team, striker, bowler, predict_button, output)

# Make predictions and evaluate the model
predictions = model.predict(X_test_scaled)
mae = mean_absolute_error(y_test, predictions)
print(f"Mean Absolute Error: {mae}")

mse = mean_squared_error(y_test, predictions)
print(f"Mean Squared Error (MSE): {mse}")

r2 = r2_score(y_test, predictions)
print(f"R-squared (R2) Score: {r2}")

"""**Data Preprocessing & Exploratory Data Analysis**"""

#EDA: Visualizations
plt.figure(figsize=(12, 8))

import matplotlib.pyplot as plt
import seaborn as sns

# Distribution Plots
plt.figure(figsize=(12, 6))
sns.histplot(y, bins=30, kde=True, color='blue')
plt.title('Distribution of Target Variable (Total Runs)')
plt.xlabel('Total Runs')
plt.ylabel('Count')
plt.show()

# Box Plots and Violin Plots
plt.figure(figsize=(16, 10))
plt.subplot(2,2, 1)
sns.boxplot(x='venue', y='total', data=df)
plt.title('Venue vs Total Runs')
plt.subplot(2,2,2)
sns.violinplot(x='bat_team', y='total', data=df)
plt.title('Batting Team vs Total Runs')
plt.subplot(2, 2, 3)
sns.boxplot(x='bowl_team', y='total', data=df)
plt.title('Bowling Team vs Total Runs')
plt.subplot(2, 2, 4)
sns.violinplot(x='batsman', y='total', data=df)
plt.title('Batsman vs Total Runs')
plt.tight_layout()